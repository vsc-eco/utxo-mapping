// Code generated by tinyjson for marshaling/unmarshaling. DO NOT EDIT.

package mapping

import (
	tinyjson "github.com/CosmWasm/tinyjson"
	jlexer "github.com/CosmWasm/tinyjson/jlexer"
	jwriter "github.com/CosmWasm/tinyjson/jwriter"
)

// suppress unused package warning
var (
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ tinyjson.Marshaler
)

func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping(in *jlexer.Lexer, out *VerificationRequest) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "block_height":
			out.BlockHeight = uint32(in.Uint32())
		case "raw_tx_hex":
			out.RawTxHex = string(in.String())
		case "merkle_proof_hex":
			out.MerkleProofHex = string(in.String())
		case "tx_index":
			out.TxIndex = uint32(in.Uint32())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping(out *jwriter.Writer, in VerificationRequest) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"block_height\":"
		out.RawString(prefix[1:])
		out.Uint32(uint32(in.BlockHeight))
	}
	{
		const prefix string = ",\"raw_tx_hex\":"
		out.RawString(prefix)
		out.String(string(in.RawTxHex))
	}
	{
		const prefix string = ",\"merkle_proof_hex\":"
		out.RawString(prefix)
		out.String(string(in.MerkleProofHex))
	}
	{
		const prefix string = ",\"tx_index\":"
		out.RawString(prefix)
		out.Uint32(uint32(in.TxIndex))
	}
	out.RawByte('}')
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v VerificationRequest) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *VerificationRequest) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping(l, v)
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping1(in *jlexer.Lexer, out *UtxoRegistry) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		in.Skip()
		*out = nil
	} else {
		in.Delim('[')
		if *out == nil {
			if !in.IsDelim(']') {
				*out = make(UtxoRegistry, 0, 2)
			} else {
				*out = UtxoRegistry{}
			}
		} else {
			*out = (*out)[:0]
		}
		for !in.IsDelim(']') {
			var v1 [3]int64
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('[')
				v2 := 0
				for !in.IsDelim(']') {
					if v2 < 3 {
						(v1)[v2] = int64(in.Int64())
						v2++
					} else {
						in.SkipRecursive()
					}
					in.WantComma()
				}
				in.Delim(']')
			}
			*out = append(*out, v1)
			in.WantComma()
		}
		in.Delim(']')
	}
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping1(out *jwriter.Writer, in UtxoRegistry) {
	if in == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
		out.RawString("null")
	} else {
		out.RawByte('[')
		for v3, v4 := range in {
			if v3 > 0 {
				out.RawByte(',')
			}
			out.RawByte('[')
			for v5 := range v4 {
				if v5 > 0 {
					out.RawByte(',')
				}
				out.Int64(int64((v4)[v5]))
			}
			out.RawByte(']')
		}
		out.RawByte(']')
	}
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v UtxoRegistry) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping1(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *UtxoRegistry) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping1(l, v)
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping2(in *jlexer.Lexer, out *Utxo) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "tx_id":
			out.TxId = string(in.String())
		case "vout":
			out.Vout = uint32(in.Uint32())
		case "amount":
			out.Amount = int64(in.Int64())
		case "pk_script":
			if in.IsNull() {
				in.Skip()
				out.PkScript = nil
			} else {
				out.PkScript = in.Bytes()
			}
		case "tag":
			out.Tag = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping2(out *jwriter.Writer, in Utxo) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"tx_id\":"
		out.RawString(prefix[1:])
		out.String(string(in.TxId))
	}
	{
		const prefix string = ",\"vout\":"
		out.RawString(prefix)
		out.Uint32(uint32(in.Vout))
	}
	{
		const prefix string = ",\"amount\":"
		out.RawString(prefix)
		out.Int64(int64(in.Amount))
	}
	{
		const prefix string = ",\"pk_script\":"
		out.RawString(prefix)
		out.Base64Bytes(in.PkScript)
	}
	{
		const prefix string = ",\"tag\":"
		out.RawString(prefix)
		out.String(string(in.Tag))
	}
	out.RawByte('}')
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v Utxo) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping2(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *Utxo) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping2(l, v)
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping3(in *jlexer.Lexer, out *TxSpendsRegistry) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		in.Skip()
		*out = nil
	} else {
		in.Delim('[')
		if *out == nil {
			if !in.IsDelim(']') {
				*out = make(TxSpendsRegistry, 0, 4)
			} else {
				*out = TxSpendsRegistry{}
			}
		} else {
			*out = (*out)[:0]
		}
		for !in.IsDelim(']') {
			var v9 string
			v9 = string(in.String())
			*out = append(*out, v9)
			in.WantComma()
		}
		in.Delim(']')
	}
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping3(out *jwriter.Writer, in TxSpendsRegistry) {
	if in == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
		out.RawString("null")
	} else {
		out.RawByte('[')
		for v10, v11 := range in {
			if v10 > 0 {
				out.RawByte(',')
			}
			out.String(string(v11))
		}
		out.RawByte(']')
	}
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v TxSpendsRegistry) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping3(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *TxSpendsRegistry) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping3(l, v)
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping4(in *jlexer.Lexer, out *SystemSupply) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "active_supply":
			out.ActiveSupply = int64(in.Int64())
		case "user_supply":
			out.UserSupply = int64(in.Int64())
		case "fee_supply":
			out.FeeSupply = int64(in.Int64())
		case "base_fee_rate":
			out.BaseFeeRate = int64(in.Int64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping4(out *jwriter.Writer, in SystemSupply) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"active_supply\":"
		out.RawString(prefix[1:])
		out.Int64(int64(in.ActiveSupply))
	}
	{
		const prefix string = ",\"user_supply\":"
		out.RawString(prefix)
		out.Int64(int64(in.UserSupply))
	}
	{
		const prefix string = ",\"fee_supply\":"
		out.RawString(prefix)
		out.Int64(int64(in.FeeSupply))
	}
	{
		const prefix string = ",\"base_fee_rate\":"
		out.RawString(prefix)
		out.Int64(int64(in.BaseFeeRate))
	}
	out.RawByte('}')
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v SystemSupply) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping4(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *SystemSupply) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping4(l, v)
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping5(in *jlexer.Lexer, out *SigningData) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "tx":
			out.Tx = string(in.String())
		case "unsigned_sig_hashes":
			if in.IsNull() {
				in.Skip()
				out.UnsignedSigHashes = nil
			} else {
				in.Delim('[')
				if out.UnsignedSigHashes == nil {
					if !in.IsDelim(']') {
						out.UnsignedSigHashes = make([]UnsignedSigHash, 0, 1)
					} else {
						out.UnsignedSigHashes = []UnsignedSigHash{}
					}
				} else {
					out.UnsignedSigHashes = (out.UnsignedSigHashes)[:0]
				}
				for !in.IsDelim(']') {
					var v12 UnsignedSigHash
					tinyjsonA043f2bcDecodeBtcMappingContractContractMapping6(in, &v12)
					out.UnsignedSigHashes = append(out.UnsignedSigHashes, v12)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping5(out *jwriter.Writer, in SigningData) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"tx\":"
		out.RawString(prefix[1:])
		out.String(string(in.Tx))
	}
	{
		const prefix string = ",\"unsigned_sig_hashes\":"
		out.RawString(prefix)
		if in.UnsignedSigHashes == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v13, v14 := range in.UnsignedSigHashes {
				if v13 > 0 {
					out.RawByte(',')
				}
				tinyjsonA043f2bcEncodeBtcMappingContractContractMapping6(out, v14)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v SigningData) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping5(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *SigningData) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping5(l, v)
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping6(in *jlexer.Lexer, out *UnsignedSigHash) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "index":
			out.Index = uint32(in.Uint32())
		case "sig_hash":
			out.SigHash = string(in.String())
		case "witness_script":
			out.WitnessScript = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping6(out *jwriter.Writer, in UnsignedSigHash) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"index\":"
		out.RawString(prefix[1:])
		out.Uint32(uint32(in.Index))
	}
	{
		const prefix string = ",\"sig_hash\":"
		out.RawString(prefix)
		out.String(string(in.SigHash))
	}
	{
		const prefix string = ",\"witness_script\":"
		out.RawString(prefix)
		out.String(string(in.WitnessScript))
	}
	out.RawByte('}')
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping7(in *jlexer.Lexer, out *SendParams) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "amount":
			out.Amount = int64(in.Int64())
		case "address":
			out.Address = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping7(out *jwriter.Writer, in SendParams) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"amount\":"
		out.RawString(prefix[1:])
		out.Int64(int64(in.Amount))
	}
	{
		const prefix string = ",\"address\":"
		out.RawString(prefix)
		out.String(string(in.Address))
	}
	out.RawByte('}')
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v SendParams) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping7(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *SendParams) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping7(l, v)
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping8(in *jlexer.Lexer, out *PublicKeys) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "primary_public_key":
			out.PrimaryPubKey = string(in.String())
		case "backup_public_key":
			out.BackupPubKey = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping8(out *jwriter.Writer, in PublicKeys) {
	out.RawByte('{')
	first := true
	_ = first
	if in.PrimaryPubKey != "" {
		const prefix string = ",\"primary_public_key\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.PrimaryPubKey))
	}
	if in.BackupPubKey != "" {
		const prefix string = ",\"backup_public_key\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.BackupPubKey))
	}
	out.RawByte('}')
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v PublicKeys) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping8(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *PublicKeys) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping8(l, v)
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping9(in *jlexer.Lexer, out *MappingResults) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		in.Skip()
		*out = nil
	} else {
		in.Delim('[')
		if *out == nil {
			if !in.IsDelim(']') {
				*out = make(MappingResults, 0, 8)
			} else {
				*out = MappingResults{}
			}
		} else {
			*out = (*out)[:0]
		}
		for !in.IsDelim(']') {
			var v15 *MappingResult
			if in.IsNull() {
				in.Skip()
				v15 = nil
			} else {
				if v15 == nil {
					v15 = new(MappingResult)
				}
				(*v15).UnmarshalTinyJSON(in)
			}
			*out = append(*out, v15)
			in.WantComma()
		}
		in.Delim(']')
	}
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping9(out *jwriter.Writer, in MappingResults) {
	if in == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
		out.RawString("null")
	} else {
		out.RawByte('[')
		for v16, v17 := range in {
			if v16 > 0 {
				out.RawByte(',')
			}
			if v17 == nil {
				out.RawString("null")
			} else {
				(*v17).MarshalTinyJSON(out)
			}
		}
		out.RawByte(']')
	}
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v MappingResults) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping9(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *MappingResults) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping9(l, v)
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping10(in *jlexer.Lexer, out *MappingResult) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "instruction":
			out.Instruction = string(in.String())
		case "deposit_address":
			out.DepositAddress = string(in.String())
		case "deposit_network":
			out.Depositnetwork = NetworkName(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping10(out *jwriter.Writer, in MappingResult) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"instruction\":"
		out.RawString(prefix[1:])
		out.String(string(in.Instruction))
	}
	if in.DepositAddress != "" {
		const prefix string = ",\"deposit_address\":"
		out.RawString(prefix)
		out.String(string(in.DepositAddress))
	}
	if in.Depositnetwork != "" {
		const prefix string = ",\"deposit_network\":"
		out.RawString(prefix)
		out.String(string(in.Depositnetwork))
	}
	out.RawByte('}')
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v MappingResult) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping10(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *MappingResult) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping10(l, v)
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping11(in *jlexer.Lexer, out *MappingParams) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "tx_data":
			if in.IsNull() {
				in.Skip()
				out.TxData = nil
			} else {
				if out.TxData == nil {
					out.TxData = new(VerificationRequest)
				}
				(*out.TxData).UnmarshalTinyJSON(in)
			}
		case "instructions":
			if in.IsNull() {
				in.Skip()
				out.Instructions = nil
			} else {
				in.Delim('[')
				if out.Instructions == nil {
					if !in.IsDelim(']') {
						out.Instructions = make([]string, 0, 4)
					} else {
						out.Instructions = []string{}
					}
				} else {
					out.Instructions = (out.Instructions)[:0]
				}
				for !in.IsDelim(']') {
					var v18 string
					v18 = string(in.String())
					out.Instructions = append(out.Instructions, v18)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping11(out *jwriter.Writer, in MappingParams) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"tx_data\":"
		out.RawString(prefix[1:])
		if in.TxData == nil {
			out.RawString("null")
		} else {
			(*in.TxData).MarshalTinyJSON(out)
		}
	}
	{
		const prefix string = ",\"instructions\":"
		out.RawString(prefix)
		if in.Instructions == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v19, v20 := range in.Instructions {
				if v19 > 0 {
					out.RawByte(',')
				}
				out.String(string(v20))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v MappingParams) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping11(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *MappingParams) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping11(l, v)
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping12(in *jlexer.Lexer, out *DexInstruction) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "type":
			out.Type = string(in.String())
		case "version":
			out.Version = string(in.String())
		case "asset_in":
			out.AssetIn = string(in.String())
		case "asset_out":
			out.AssetOut = string(in.String())
		case "recipient":
			out.Recipient = string(in.String())
		case "slippage_bps":
			if in.IsNull() {
				in.Skip()
				out.SlippageBps = nil
			} else {
				if out.SlippageBps == nil {
					out.SlippageBps = new(int)
				}
				*out.SlippageBps = int(in.Int())
			}
		case "min_amount_out":
			if in.IsNull() {
				in.Skip()
				out.MinAmountOut = nil
			} else {
				if out.MinAmountOut == nil {
					out.MinAmountOut = new(int64)
				}
				*out.MinAmountOut = int64(in.Int64())
			}
		case "beneficiary":
			if in.IsNull() {
				in.Skip()
				out.Beneficiary = nil
			} else {
				if out.Beneficiary == nil {
					out.Beneficiary = new(string)
				}
				*out.Beneficiary = string(in.String())
			}
		case "ref_bps":
			if in.IsNull() {
				in.Skip()
				out.RefBps = nil
			} else {
				if out.RefBps == nil {
					out.RefBps = new(int)
				}
				*out.RefBps = int(in.Int())
			}
		case "return_address":
			if in.IsNull() {
				in.Skip()
				out.ReturnAddress = nil
			} else {
				if out.ReturnAddress == nil {
					out.ReturnAddress = new(ReturnAddress)
				}
				tinyjsonA043f2bcDecodeBtcMappingContractContractMapping13(in, out.ReturnAddress)
			}
		case "metadata":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.Metadata = make(map[string]string)
				} else {
					out.Metadata = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v21 string
					v21 = string(in.String())
					(out.Metadata)[key] = v21
					in.WantComma()
				}
				in.Delim('}')
			}
		case "amount_in":
			out.AmountIn = int64(in.Int64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping12(out *jwriter.Writer, in DexInstruction) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"type\":"
		out.RawString(prefix[1:])
		out.String(string(in.Type))
	}
	{
		const prefix string = ",\"version\":"
		out.RawString(prefix)
		out.String(string(in.Version))
	}
	{
		const prefix string = ",\"asset_in\":"
		out.RawString(prefix)
		out.String(string(in.AssetIn))
	}
	{
		const prefix string = ",\"asset_out\":"
		out.RawString(prefix)
		out.String(string(in.AssetOut))
	}
	{
		const prefix string = ",\"recipient\":"
		out.RawString(prefix)
		out.String(string(in.Recipient))
	}
	if in.SlippageBps != nil {
		const prefix string = ",\"slippage_bps\":"
		out.RawString(prefix)
		out.Int(int(*in.SlippageBps))
	}
	if in.MinAmountOut != nil {
		const prefix string = ",\"min_amount_out\":"
		out.RawString(prefix)
		out.Int64(int64(*in.MinAmountOut))
	}
	if in.Beneficiary != nil {
		const prefix string = ",\"beneficiary\":"
		out.RawString(prefix)
		out.String(string(*in.Beneficiary))
	}
	if in.RefBps != nil {
		const prefix string = ",\"ref_bps\":"
		out.RawString(prefix)
		out.Int(int(*in.RefBps))
	}
	if in.ReturnAddress != nil {
		const prefix string = ",\"return_address\":"
		out.RawString(prefix)
		tinyjsonA043f2bcEncodeBtcMappingContractContractMapping13(out, *in.ReturnAddress)
	}
	if len(in.Metadata) != 0 {
		const prefix string = ",\"metadata\":"
		out.RawString(prefix)
		{
			out.RawByte('{')
			v22First := true
			for v22Name, v22Value := range in.Metadata {
				if v22First {
					v22First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v22Name))
				out.RawByte(':')
				out.String(string(v22Value))
			}
			out.RawByte('}')
		}
	}
	{
		const prefix string = ",\"amount_in\":"
		out.RawString(prefix)
		out.Int64(int64(in.AmountIn))
	}
	out.RawByte('}')
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v DexInstruction) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping12(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *DexInstruction) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping12(l, v)
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping13(in *jlexer.Lexer, out *ReturnAddress) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "chain":
			out.Chain = string(in.String())
		case "address":
			out.Address = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping13(out *jwriter.Writer, in ReturnAddress) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"chain\":"
		out.RawString(prefix[1:])
		out.String(string(in.Chain))
	}
	{
		const prefix string = ",\"address\":"
		out.RawString(prefix)
		out.String(string(in.Address))
	}
	out.RawByte('}')
}
func tinyjsonA043f2bcDecodeBtcMappingContractContractMapping14(in *jlexer.Lexer, out *AccountInfo) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "modified_at":
			out.ModifiedAt = uint64(in.Uint64())
		case "address":
			out.Address = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA043f2bcEncodeBtcMappingContractContractMapping14(out *jwriter.Writer, in AccountInfo) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"modified_at\":"
		out.RawString(prefix[1:])
		out.Uint64(uint64(in.ModifiedAt))
	}
	{
		const prefix string = ",\"address\":"
		out.RawString(prefix)
		out.String(string(in.Address))
	}
	out.RawByte('}')
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v AccountInfo) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA043f2bcEncodeBtcMappingContractContractMapping14(w, v)
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *AccountInfo) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA043f2bcDecodeBtcMappingContractContractMapping14(l, v)
}
